;rc программа реконфигурации памяти и определения кол-ва памяти во всех подключенных платах памяти типа 1841
;rc выполняется тест блоками по 16k записью 0xaa55 и считывание (без проверки четности). При успехе (совпадении)  
;rc 16k блок заполняется нулями и снова происходит считывание и проверка. 
;rc В случае ошибки в адресах 0..384k происходит реконфигурация.
;rc В случае ошибки в первых 16k платы 2b0 после реконфигурации или при отсутствии порта 2b0 система останавливается.
;rc В случае ошибки в 384...640k объем памяти сокращается без реконфигурации.
;rc  По итогам проверки в обл данных BIOS заполняется таблица tabl1 в формате:
;rc номер порта платы (2 байта), число исправных килобайт на плате (кратно 16k) (2 байта)
;rc число исправных килобайт на плате 2b0 заносится также в mem_siz в области данных BIOS.
;rc этим значением воспользуется ОС. 
;rc Интервал 512..640 разделяется всеми платами, т.е. если 2 платы по 512 типа 1841 и одна плата 128 типа 1840,
;rc то в tabl1 будет стоять 640k у обоих плат.

;rc тестирование памяти здесь неполное (aa55 и нули). Основная плата 2b0 полностью тестируется дальше в e190
;rc IBM-ской программой stgtst. Дополнительные платы остаются нетестированными в полной мере. 

 	assume	ds:abs0
ca0:                		 
 	in	al,port_b
 	and	al,0cfh		;rc 0b1100.1111	clear bit5 (i/o ch err off), bit4 (ram err off)
 	out	port_b,al
 	xor	ax,ax
 	mov	ds,ax
 	mov	es,ax
 	mov	dx,213h
 	mov	al,01
 	out	dx,al	   ; активизировать плату расширения rc установить сигнал EXT, как и в IBM
 	mov	bx,0
 	mov	dx,2b0h
 	in	al,dx      	;rc читать регистр главной платы памяти 2b0
 	and	al,0ch
 	cmp	al,0ch          ;rc все 1?
 	jz	ca1      
 	mov	bx,res_fl
ca1:	mov	al,0ah
 	out	dx,al           ;rc 0b0000.1010 - проверочный паттерн
 	in	al,dx           ;rc читать порт обратно
 	and	al,0fh          ;rc 0b0000.1111 только младшая тетрада
 	cmp	al,0ah          ;rc сравниваем с записаным
 	jnz	oshp	   ; нет платы 2B0 rc если не совпало (случай модуля ЕС1840, не только отсутствия 2b0!)
 	mov	al,0ch
 	out	dx,al           ;rc 0b0000.1100 разрешить запись и чтение
 	xor	al,al  ; сброс активности остальных плат памяти rc в цикле пишется 00 (выкл зп/чт)...
ca2:	inc	dx               
 	out	dx,al
 	cmp	dl,0b3h         ;rc ...в порты 2b1...2b3.
 	jnz	ca2             ;rc конец цикла
ca22:	mov	bx,res_fl
 	mov	cx,2000h        ;rc счетчик для проверки 8к слов - 16кб
 	cmp	bx,1234h        ;rc есть признак горячей перезагрузки?
 	jz	ca8
 	mov	ax,0f000h
 	mov	ss,ax           ;rc как бы стек в ПЗУ
ca7a:	mov	sp,offset caw   ;rc адрес возврата для stgtst_cnt будет ca3
ca7:	jmp	stgtst_cnt      ;rc проверка 16кб и их очистка
ca3:	mov	cx,2000h
 	je	ca8             ;rc нет ошибки?->ca8
 	mov	dx,2b0h    ; сбой в первых 16К основной платы
 	in	al,dx	   ; памяти
 	test	al,03	   ; реконфигурация была? rc0b0000.0011
 	jz	ca6        ;rc 00 в младших разрядах означает, что реконфига не было

;--------------rc случай ошибки в первых 16k 2b0, если реконфиг уже был - неустранимый
oshp:                      ; была реконфигурация  rc или вообще нет платы 2b0 или память 1840
 	mov	bl,al
 	mov	al,89h     ;rc 0b1000.1001 установить порты A,B на вывод, порт C на ввод
 	out	cmd_port,al
 	mov	al,04      ;rc 0b0000.0100
ca5:	out	port_a,al  ;rc вывод в порт A!! чего никогда не бывает в IBM
 	xor	cx,cx
ca4:	loop	ca4	   ;rc бесконечный цикл с выводом в порт A кода реконфиг (если сбой 16k) и 04h... 
			   ;rc ...или прочтенного по 2b0 (если нет платы) и 04h
 	xchg	bl,al
 	jmp	ca5
;--------------rc конец ошибки

ca6:	or	al,3       ;rc реконфига не было и ошибка первых 16k: ставим отказ банка 0
 	out	dx,al
 	jmp	ca7a       ;rc и возвращаемся на тест первых 16k

			;rc сюда после горячей перезагрузки или отсутствия ошибки первых 16k
			;rc cx в обоих случаях содержит 2000h
ca8:	xor	ax,ax
 	cld
 	xor	si,si
 	xor	di,di
 	mov	bp,2b0h
 	rep	stosw       ;rc очистка первых 16k нулями
 	mov	res_fl,bx
ca9:	mov	dx,0400h    ;rc сегмент, следующий за первыми 16k
 	mov	bx,16       ;rc инициализировать счетчик исправных килобайт (будет писаться в tabl1 и mem_siz)

			;rc основной цикл-тест платы
ca10:	mov	es,dx       ;rc очередной сегмент для stos
 	xor	di,di
 	mov	ax,0aa55h
 	mov	cx,ax
 	mov	es:[di],ax  ; проверка наличия очередных 16К памяти rc: пишем aa55...
 	mov	al,0fh      ;rc зачем???? затрется же сразу
 	mov	ax,es:[di]  ;rc ...и сразу читаем
 	xor	ax,cx       ;rc сравниваем с эталоном
 	jnz	ca11        ;rc разночтение->нет памяти или ошибка->ca11
 	mov	cx,2000h
 	rep	stosw       ;rc есть память->затрем очередные 16k нулями (ax=00 будет при идентичности с эталоном)
 	mov	cx,2000h
 	xor	di,di
 	repz	scasw	   ; есть сбойные адреса в порции 16К? rc сканирование на отличные от нуля в затертом массиве
 	or	cx,ax      ;rc определим факт сбоя, если его не было, cx=0. or, чтобы на флаги повлияло  
 	jnz	ca11	   ; да
 	add	dx,0400h   ; нет rc следующий сегмент (след 16k массив)
 	add	bx,16      ;rc увеличим счетчик исправных килобайт на только что проверенные
 	cmp	dh,0a0h    ;rc достигнута граница 640k?
 	jnz	ca10       ;rc нет - продолжить цикл-тест
 	jmp	ca12       ;rc да

			;rc здесь мы в случае отсутствия очередных 16k или обнаружения сбоя в очередных 16k
ca11:	cmp	dh,60h     ;rc сравниваем адрес сегмента с 384K
 	jnb	ca12       ;rc адрес >=384 ->ca12
 	mov	dx,bp	   ; адрес меньше 512К  rc ошибка в заводском комментарии!! должно было стоять меньше 384k
 	in	al,dx      ;rc читаем порт платы
 	test	al,03      ;rc была реконфигурация?
 	jnz	ca12       ;rc если реконфигурация была или порт отсутствует ->ca12
			;rc если не было - надо реконфигурировать
 	mov	dx,es      ;rc восстанавливаем сегмент в dx
 	and	dh,60h     ;rc выделяем из него адрес банка
 	xor	dh,60h     ;rc инвертируем адрес банка
 	mov	cl,5
 	shr	dh,cl      ;rc смещаем в младшие разряды - получили код реконфигурации
 	or	al,dh      ;rc сочетаем с кодами зп/чт модуля
 	mov	dx,bp
 	out	dx,al      ;rc записали в порт модуля
 	xor	dx,dx
 	xor	bx,bx
 	jmp	ca10       ;rc возвращаемся на тестирование модуля с самого начала

			;rc здесь мы если:
			;rc а)ошибка возникла при первом проходе в 384k...640k
			;rc б)ошибка возникла при втором проходе в 384k...512k - перенесенная старая 
			;rc в)ошибка возникла в 16k..384k уже после реконфигурации
			;rc во всех этих случаях, если мы на 2b0, память будет сокращена
			;rc до последнего безошибочного 16-кб блока, т.е. до текущего bx.
			;rc г)достигнута граница 640k без ошибок
			;rc если текущая плата реально есть, текущий bx будет записан в tabl1.

ca12:	 	 	   ; сброс активности текущего модуля памяти
 	mov	dx,bp
 	in	al,dx
 	and	al,0f3h    ;rc 0b1111.0011 - отключить чт/зп
 	out	dx,al
 	mov	dx,2b0h    ; возврат на плату памяти 2B0 rc(т.к. таблица tabl1 находится в ней)
 	in	al,dx
 	or	al,0ch     ;rc 0b0000.1100 - включаем чт/зп у 2b0
 	out	dx,al
 	test	bp,3       ;rc текущая плата была 2b0?
 	jnz	ca14       ;rc нет->проверить bx на 0 (была ли плата)
 	mov	mem_siz,bx ;rc да - сокращаем память DOS до последнего безошибочного блока
ca15:
 	mov	si,csi	   ;rc csi - указатель в tabl1, при первом проходе csi=0
 	mov	tabl1[si],bp     ;rc пишем в tabl1 номер порта текущей платы
 	mov	tabl1[si+2],bx   ;rc и число исправных кб
 	inc	bp               ;rc следующая плата
 	add	csi,4            ;rc указатель на следующий элемент в таблице tabl1
ca16:	cmp	bp,2b4h          ;rc все платы перебраны?
 	jnb	ca13             ;rc да->выход и продолжение POST
 	mov	bx,0             ;rc иначе переход на тест след платы: обнулить счетчик кб,
 	mov	al,0ch
 	mov	dx,bp            
 	out	dx,al            ;rc вкл чт/зп и сбросить реконфиг след платы 
 	mov	dx,2b0h 	; сброс активности 2b0
 	in	al,dx
 	and	al,0f3h          ;rc т.е. откл чт/зп 2b0, реконфиг ост как есть
 	out	dx,al
 	mov	dx,0             ;rc начальный сегмент для новой платы
 	jmp	ca10             ;rc переход на тест новой платы

ca14:	cmp	bx,0             ;rc платы 2b1..2b3 не было или сбой в первых 16k?
 	jnz	ca15             ;rc нет ->пишем в таблицу, как обычно
 	inc	bp               ;rc иначе новая плата сразу
 	jmp	ca16
ca13:                            ;rc мероприятия по выходу
 	mov	ax,data          
 	mov	ds,ax            ;rc восст ds на обл данных BIOS
 	mov	bp,0
 	jmp	c21              ;продолжение теста
